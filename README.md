# sparse_matrix_math
Header only, C++17 library for solving systems of equations with sparse matrices. Provides [iterative methods](#Iterative-Methods) for solving systems of linear equations. Matrices can be represented in [triplet/coordinate format](https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_(COO)) and [compressed sparse row format](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)). There is support for [preconditioned iterations](#Preconditioned-Iterations) for some of the implemented methods. Methods can be [run in parallel](#Parallel-Implementation). Limited support for loading [matrix market](#Matrix-Market) files is provided.

# Iterative Methods
Currently available methods are Krylov iterative methods derivatives of the BiConjugate Gradient Method. These methods can work with positive definite, negative definite and indefinite matrices. In case of symmetric positive definite and symmetric negative definite matrix the methods will converge to the exact answer. Theoretically speaking given SPD or SND matrices the methods will find the exact answer after no more that `m` steps where `m` is the size of the matrix. In the case of indefinite matrix the methods can occasionally diverge. In that case the method must be restarted with different initial guess. Keep in mind that there is no Krylov method which is proven to converge for general indefinite matrix.
## BiConjugate Gradient Symmetric Method
This is a variant of the BiConjugate Gradient, where the input matrix is known to be symmetric. For SPD matrix would yeald the exactly the same result as the Conjugate Gradient method. Example call:
```cpp
SMM::CSRMatrix m;
// Fill m
...
// Init the right hand side somehow
float* rhs = initRhs()
// The result will be stored here. The vector must be preallocated by the caller.
float* res = new float[m.getDenseRowCount()];
// The method will do no more than maxIterations iterations. If maxIterations is -1 the method will use the number of rows of the matrix as stopping condition.
const int maxIterations = 100;
// This will be used by the method as a condition for convergence. If the second norm of the residual becomes smaller, the method will end.
const float L2NormCondition = 1e-6;
SMM::SolverStatus status = SMM::BiCGSymmetric(m, rhs, res, maxIterations, L2NormCondition);
```
## Conjugate Squared Method
Transpose free variation of the BiConjugate Gradient method. Can be used with general matricies. In practice, the method usually converges twice as fast as the BiCG method, but the squaring of the underlying residual polynomial makes the method more susceptible to rounding errors.
```cpp
SMM::CSRMatrix m;
// Fill m
...
// Init the right hand side somehow
float* rhs = initRhs()
// The result will be stored here. The vector must be preallocated by the caller.
float* res = new float[m.getDenseRowCount()];
// The method will do no more than maxIterations iterations. If maxIterations is -1 the method will use the number of rows of the matrix as stopping condition.
const int maxIterations = 100;
// This will be used by the method as a condition for convergence. If the second norm of the residual becomes smaller, the method will end.
const float L2NormCondition = 1e-6;
SMM::SolverStatus status = SMM::BiCGSquared(m, rhs, res, maxIterations, L2NormCondition);
```
## BiConjugate Gradient Stabilized
Another transpose free variant of the BiConjugate Gradient Method which can be used on general matrices. This method does not square the residual polynomial, but uses polynomial product which smoothens the convergence behavior.
```cpp
SMM::CSRMatrix m;
// Fill m
...
// Init the right hand side somehow
float* rhs = initRhs()
// The result will be stored here. The vector must be preallocated by the caller.
float* res = new float[m.getDenseRowCount()];
// The method will do no more than maxIterations iterations. If maxIterations is -1 the method will use the number of rows of the matrix as stopping condition.
const int maxIterations = 100;
// This will be used by the method as a condition for convergence. If the second norm of the residual becomes smaller, the method will end.
const float L2NormCondition = 1e-6;
SMM::SolverStatus status = SMM::BiCGStab(m, rhs, res, maxIterations, L2NormCondition);
```
For preconditioned iterations check [Preconditioners](#preconditioners)

# Preconditioners
Preconditioned iterations are allowed only for the [BiConjugate Gradient Stabilized](#biconjugate-gradient-stabilized). Preconditioners are generated by `SMM::CSRMatrix::getPreconditioner(SMM::SolverPreconditioner)` and then passed to `BiCGStab`. Example usage:
 ```cpp
SMM::CSRMatrix m;
// Fill m
...
// Init the right hand side somehow
float* rhs = initRhs()
// The result will be stored here. The vector must be preallocated by the caller.
float* res = new float[m.getDenseRowCount()];
// The method will do no more than maxIterations iterations. If maxIterations is -1 the method will use the number of rows of the matrix as stopping condition.
const int maxIterations = 100;
// This will be used by the method as a condition for convergence. If the second norm of the residual becomes smaller, the method will end.
const float L2NormCondition = 1e-6;
SMM::SolverStatus status = SMM::BiCGStab(m, rhs, res, maxIterations, L2NormCondition, preconditioner, m.getPreconditioner(SMM::SolverPreconditioner::SYMMETRIC_GAUSS_SEIDEL));
```
## Symmetric Gauss-Seidel
Static preconditioner which does not take additional time to prepare, nor does it take additional space. It takes the form of `M = (D + L)inv(D)(D + U)` where `D`, `L` and `U` are the diagonal, lower triangular and upper triangular portions of the matrix which will be predonditioned.

# Dependencies
## Google Test
Google test is an optional dependency which is used to run the provided unit tests. The unit tests are build by default, but can be disabled by setting `SMM_UNIT_TESTS=FALSE`.

### Installing via Conan
Google Test can be installed via [conan](https://conan.io/) using the provided `conanfile.txt`.
```sh
conan install conanfile.txt -if <path_to_build_folder> --build=missing -s build_type=<desired_build_type>
```
Where:
* `<path_to_build_folder>` is the folder where the project is going to be built. It could be a top level project, where cpp_tm is added as subdirectory.
* `<desired_build_type>` could be `Debug` or `Release`

Note the default generator is `cmake_find_package_multi` and it can be changed if needed. If `cmake_find_package_multi` is used it is **important** not to forget to
set these two CMake `CMAKE_PREFIX_PATH`, `CMAKE_MODULE_PATH` so that `find_package` utility.find_package` function can find the files generated by conan. Both folders should be set
to whatever `<path_to_build_folder>` was chosen in the step above, using absolute path is imperative. Note also that for building missing packages for `gtest` C++11 standard library is needed (libstdc++11).
You might need to edit your default conan profile or create new profile.

### Using CMake find_package for Dependencies
If you have `FindGTest.cmake` already existing, append the absolute path to the directory containing it to`CMAKE_PREFIX_PATH` and `CMAKE_MODULE_PATH`

## Multithreading
Multithreading can be enabled by setting `SMM_MULTITHREADING` to the desired multithreading library. Currently supported options are `None` (by default) and `CPPTM`.

### CPPTM
cpp_tm is a small header only library available [here](https://github.com/vasil-pashov/cpp_tm). To download and install it follow the steps provided [here](https://github.com/vasil-pashov/cpp_tm/blob/master/README.md#install).

After cpp_tm has been installed to the system it can be used by *sparse_matrix_math* by setting the `SMM_MULTITHREADING="CPPTM"` when building *sparse_matrix_math*. To see concrete example how to build and run tests with *cpp_tm* enabled checkout the [Build and Run Tests](#Build-and-Run-Tests) section

# Build and Run Tests
```sh
git clone https://github.com/vasil-pashov/sparse_matrix_math.git
cd sparse_matrix_math
mkdir build
conan install . --build=missing -s build_type=Release -if ./build
# Build without multithreading
# cmake -B"./build" -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=${PWD}/build -DCMAKE_MODULE_PATH=${PWD}/build

# Build with cpp_tm library
cmake -B"./build" -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=${PWD}/build -DCMAKE_MODULE_PATH=${PWD}/build -DSMM_MULTITHREADING="CPPTM"
cd build
cmake --build . --config Release
cd test/unit
ctest
```

# Install
The library can be installed to the system, so that other cmake project can use it via the `fing_package` utility.
```sh
git clone https://github.com/vasil-pashov/cpp_tm.git
cd cpp_tm
mkdir build
cmake -B"./build" -DCMAKE_BUILD_TYPE=Release -DCPPTM_UNIT_TESTS=OFF
cd build
sudo cmake --install ./
```

If the library is to be installed with multithreading support change `cmake -B"./build" -DCMAKE_BUILD_TYPE=Release -DCPPTM_UNIT_TESTS=OFF` with `cmake -B"./build" -DCMAKE_BUILD_TYPE=Release -DCPPTM_UNIT_TESTS=OFF -DSMM_MULTITHREADING="CPPTM"` in the above.

To change the install directories use `CMAKE_INSTALL_PREFIX` and `CONFIG_INSTALL_DIR` variables (if some nonstandard structure is needed). Where `CONFIG_INSTALL_DIR` gets appended to `CMAKE_INSTALL_PREFIX`.
